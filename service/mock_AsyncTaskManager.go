// Code generated by mockery v2.26.1. DO NOT EDIT.

package service

import (
	models "scheduler0/models"

	mock "github.com/stretchr/testify/mock"

	utils "scheduler0/utils"
)

// MockAsyncTaskManager is an autogenerated mock type for the AsyncTaskManager type
type MockAsyncTaskManager struct {
	mock.Mock
}

// AddSubscriber provides a mock function with given fields: taskId, subscriber
func (_m *MockAsyncTaskManager) AddSubscriber(taskId uint64, subscriber func(models.AsyncTask)) (uint64, *utils.GenericError) {
	ret := _m.Called(taskId, subscriber)

	var r0 uint64
	var r1 *utils.GenericError
	if rf, ok := ret.Get(0).(func(uint64, func(models.AsyncTask)) (uint64, *utils.GenericError)); ok {
		return rf(taskId, subscriber)
	}
	if rf, ok := ret.Get(0).(func(uint64, func(models.AsyncTask)) uint64); ok {
		r0 = rf(taskId, subscriber)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(uint64, func(models.AsyncTask)) *utils.GenericError); ok {
		r1 = rf(taskId, subscriber)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.GenericError)
		}
	}

	return r0, r1
}

// AddTasks provides a mock function with given fields: input, requestId, service
func (_m *MockAsyncTaskManager) AddTasks(input string, requestId string, service string) ([]uint64, *utils.GenericError) {
	ret := _m.Called(input, requestId, service)

	var r0 []uint64
	var r1 *utils.GenericError
	if rf, ok := ret.Get(0).(func(string, string, string) ([]uint64, *utils.GenericError)); ok {
		return rf(input, requestId, service)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) []uint64); ok {
		r0 = rf(input, requestId, service)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string) *utils.GenericError); ok {
		r1 = rf(input, requestId, service)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.GenericError)
		}
	}

	return r0, r1
}

// DeleteSubscriber provides a mock function with given fields: taskId, subscriberId
func (_m *MockAsyncTaskManager) DeleteSubscriber(taskId uint64, subscriberId uint64) *utils.GenericError {
	ret := _m.Called(taskId, subscriberId)

	var r0 *utils.GenericError
	if rf, ok := ret.Get(0).(func(uint64, uint64) *utils.GenericError); ok {
		r0 = rf(taskId, subscriberId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.GenericError)
		}
	}

	return r0
}

// GetNodeMode provides a mock function with given fields:
func (_m *MockAsyncTaskManager) GetSingleNodeMode() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetTaskBlocking provides a mock function with given fields: taskId
func (_m *MockAsyncTaskManager) GetTaskBlocking(taskId uint64) (chan models.AsyncTask, uint64, *utils.GenericError) {
	ret := _m.Called(taskId)

	var r0 chan models.AsyncTask
	var r1 uint64
	var r2 *utils.GenericError
	if rf, ok := ret.Get(0).(func(uint64) (chan models.AsyncTask, uint64, *utils.GenericError)); ok {
		return rf(taskId)
	}
	if rf, ok := ret.Get(0).(func(uint64) chan models.AsyncTask); ok {
		r0 = rf(taskId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan models.AsyncTask)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64) uint64); ok {
		r1 = rf(taskId)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	if rf, ok := ret.Get(2).(func(uint64) *utils.GenericError); ok {
		r2 = rf(taskId)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*utils.GenericError)
		}
	}

	return r0, r1, r2
}

// GetTaskIdWithRequestId provides a mock function with given fields: requestId
func (_m *MockAsyncTaskManager) GetTaskIdWithRequestId(requestId string) (uint64, *utils.GenericError) {
	ret := _m.Called(requestId)

	var r0 uint64
	var r1 *utils.GenericError
	if rf, ok := ret.Get(0).(func(string) (uint64, *utils.GenericError)); ok {
		return rf(requestId)
	}
	if rf, ok := ret.Get(0).(func(string) uint64); ok {
		r0 = rf(requestId)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(string) *utils.GenericError); ok {
		r1 = rf(requestId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.GenericError)
		}
	}

	return r0, r1
}

// GetTaskWithRequestIdBlocking provides a mock function with given fields: requestId
func (_m *MockAsyncTaskManager) GetTaskWithRequestIdBlocking(requestId string) (chan models.AsyncTask, uint64, *utils.GenericError) {
	ret := _m.Called(requestId)

	var r0 chan models.AsyncTask
	var r1 uint64
	var r2 *utils.GenericError
	if rf, ok := ret.Get(0).(func(string) (chan models.AsyncTask, uint64, *utils.GenericError)); ok {
		return rf(requestId)
	}
	if rf, ok := ret.Get(0).(func(string) chan models.AsyncTask); ok {
		r0 = rf(requestId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan models.AsyncTask)
		}
	}

	if rf, ok := ret.Get(1).(func(string) uint64); ok {
		r1 = rf(requestId)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	if rf, ok := ret.Get(2).(func(string) *utils.GenericError); ok {
		r2 = rf(requestId)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*utils.GenericError)
		}
	}

	return r0, r1, r2
}

// GetTaskWithRequestIdNonBlocking provides a mock function with given fields: requestId
func (_m *MockAsyncTaskManager) GetTaskWithRequestIdNonBlocking(requestId string) (*models.AsyncTask, *utils.GenericError) {
	ret := _m.Called(requestId)

	var r0 *models.AsyncTask
	var r1 *utils.GenericError
	if rf, ok := ret.Get(0).(func(string) (*models.AsyncTask, *utils.GenericError)); ok {
		return rf(requestId)
	}
	if rf, ok := ret.Get(0).(func(string) *models.AsyncTask); ok {
		r0 = rf(requestId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.AsyncTask)
		}
	}

	if rf, ok := ret.Get(1).(func(string) *utils.GenericError); ok {
		r1 = rf(requestId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.GenericError)
		}
	}

	return r0, r1
}

// GetUnCommittedTasks provides a mock function with given fields:
func (_m *MockAsyncTaskManager) GetUnCommittedTasks() ([]models.AsyncTask, *utils.GenericError) {
	ret := _m.Called()

	var r0 []models.AsyncTask
	var r1 *utils.GenericError
	if rf, ok := ret.Get(0).(func() ([]models.AsyncTask, *utils.GenericError)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []models.AsyncTask); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.AsyncTask)
		}
	}

	if rf, ok := ret.Get(1).(func() *utils.GenericError); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.GenericError)
		}
	}

	return r0, r1
}

// ListenForNotifications provides a mock function with given fields:
func (_m *MockAsyncTaskManager) ListenForNotifications() {
	_m.Called()
}

// SetSingleNodeMode provides a mock function with given fields: singleNodeMode
func (_m *MockAsyncTaskManager) SetSingleNodeMode(singleNodeMode bool) {
	_m.Called(singleNodeMode)
}

// UpdateTasksById provides a mock function with given fields: taskId, state, output
func (_m *MockAsyncTaskManager) UpdateTasksById(taskId uint64, state models.AsyncTaskState, output string) *utils.GenericError {
	ret := _m.Called(taskId, state, output)

	var r0 *utils.GenericError
	if rf, ok := ret.Get(0).(func(uint64, models.AsyncTaskState, string) *utils.GenericError); ok {
		r0 = rf(taskId, state, output)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.GenericError)
		}
	}

	return r0
}

// UpdateTasksByRequestId provides a mock function with given fields: requestId, state, output
func (_m *MockAsyncTaskManager) UpdateTasksByRequestId(requestId string, state models.AsyncTaskState, output string) *utils.GenericError {
	ret := _m.Called(requestId, state, output)

	var r0 *utils.GenericError
	if rf, ok := ret.Get(0).(func(string, models.AsyncTaskState, string) *utils.GenericError); ok {
		r0 = rf(requestId, state, output)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.GenericError)
		}
	}

	return r0
}

type mockConstructorTestingTNewMockAsyncTaskManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockAsyncTaskManager creates a new instance of MockAsyncTaskManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockAsyncTaskManager(t mockConstructorTestingTNewMockAsyncTaskManager) *MockAsyncTaskManager {
	mock := &MockAsyncTaskManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
